{"timestamp": 1720384679.026559, "stored_source_code": "md_reference_data = None\nupstream = None\nproduct = None\n# R23 - MD alignment and RMSD extraction \n\n## Contents\n\n1. Alignment\n2. RMSD\n3. RMSD against average structure\n4. RMSD over subunit\n5. RMSF\n## Alignment and preparation\nfrom mdtools.mapping import map_alignment_to_structure, align_structure_sequences\nimport MDAnalysis as mda\nfrom MDAnalysis.analysis import rms, align\nfrom pyfamsa import Aligner, Sequence\nimport json\nimport pandas as pd\nimport prody as pdy\n#matplotlib.rcParams['fontname'] = \"Arial\"\ndef load_trajectory(code, data, path):\n    \n    \"\"\"\n    loads the following files\n    - an MDAnalysis trajectory with the dried (water-removed) dcd\n    - an MDAnalysis Universe with the starting PDB (jic)\n    - an prody with the starting PDB (pretty useful when MDAnalysis fails)\n    \"\"\"\n    return dict(\n        code=code,\n        trajectory_dry = mda.Universe(\n            path + data['dry_pdb'], \n            path + data['dry_dcd'], \n            frames='all', in_memory=True\n        ),\n        reference_pdy=pdy.parsePDB(path + data['dry_pdb']),\n        reference=mda.Universe(\n            path + data['dry_pdb']\n        ),\n        time=data['time']\n    )\n\nLoading all the simulations.\npath = '../../../simulations/'\nexp01_md = []\nfor key, items in md_reference_data.items():\n    print(f\"-- code {key}\", end='')\n    exp01_md.append(load_trajectory(\n        code=key, data=items, path=path\n    ))\n    print(f\" loaded\")\nexp01_md = pd.DataFrame.from_records(exp01_md).set_index('code')\n# Analysis of the RMSF\n\nThis part is a little bit convolved because it required mapping the residues to a common alignment (otherwise, the comparison doesn't have much sense).\ndef alignment_to_fasta(alignment):\n    return \"\\n\".join([f\"> {item['id']}\\n{item['sequence']}\" for item in alignment])\nlarge_subunits_alignment = align_structure_sequences(exp01_md['reference_pdy'].to_list(), exp01_md.index.to_list(), chain='A')\n# LITTLE HACK FOR 6URA\nsmall_subunit_index = exp01_md.index.isin(['6ura', 'anciip', 'ancip'])\nsmall_subunits_alignment = align_structure_sequences(\n    exp01_md['reference_pdy'][~small_subunit_index].to_list(), \n    exp01_md[~small_subunit_index].index.to_list(), chain='B')\n\nwith open(product['rbcl_alignment'], 'w') as f:\n    f.write(alignment_to_fasta(large_subunits_alignment))\nwith open(product['rbcs_alignment'], 'w') as f:\n    f.write(alignment_to_fasta(small_subunits_alignment))\nlarge_subunits_alignment = pd.DataFrame(\n    large_subunits_alignment\n).set_index('id').T\n\n\nupper_lsu = 'name CA and (segid A or segid E or segid I or segid M)'\nlower_lsu = 'name CA and (segid C or segid G or segid K or segid O)'\nlsu = 'name CA and (segid A or segid E or segid I or segid M or segid C or segid G or segid K or segid O)'\n\nexp01_rbcl_rmsf = []\n\nfor key, item in exp01_md.iterrows():\n    print(f\"-- {key} \", end=\"\")\n    u = item['trajectory_dry'].select_atoms(lsu)\n    R = rms.RMSF(u)\n    results = R.run()\n    rmsf_values = results.results.rmsf\n    forward_residue_map, backward_residue_map = map_alignment_to_structure(\n        structure=item['reference_pdy'], \n        aligned_sequence=large_subunits_alignment[key].to_list()[0],\n        on_chain='A'\n    )\n    try:\n        reference_pdy = item['reference_pdy'].select('(chain A or chain C or chain E or chain G or chain I or chain K or chain M or chain O) and name CA')\n    except TypeError:\n        reference_pdy = item['reference_pdy'].select('(chain A or chain C or chain E or chain G or chain I or chain K or chain M or chain O) and name CA')\n    for i, (res, res_pdy) in enumerate(zip(u.residues, reference_pdy.getHierView().iterResidues())):\n        try:\n            resnum = backward_residue_map.index(res.resnum)\n        \n\n            exp01_rbcl_rmsf.append(\n                dict(\n                    rmsf=rmsf_values[i], resnum=resnum, chain=res_pdy.getChid(), code=key\n\n                )\n            )    \n        except:\n            continue\n    print(\" done\")\n\n            \nexp01_rbcl_rmsf = pd.DataFrame.from_records(exp01_rbcl_rmsf)\nsmall_subunits_alignment = pd.DataFrame(\n    small_subunits_alignment\n).set_index('id').T\n\nupper_ssu = 'name CA and (segid B or segid F or segid J or segid N)'\nlower_ssu = 'name CA and (segid D or segid H or segid L or segid P)'\nssu = 'name CA and (segid B or segid F or segid J or segid N or segid D or segid H or segid L or segid P)'\n\n\nexp01_rbcs_rmsf = []\n\nfor key, item in exp01_md.iterrows():\n    print(f\"-- {key} \", end=\"\")\n    if key in ['6ura', 'anciip', 'ancip']: \n        print(\" skipped\")\n        continue\n    u = item['trajectory_dry'].select_atoms('(chainID B or chainID D or chainID F or chainID H or chainID J or chainID L or chainID N or chainID P) and name CA')\n    R = rms.RMSF(u)\n    results = R.run()\n    rmsf_values = results.results.rmsf\n    forward_residue_map, backward_residue_map = map_alignment_to_structure(\n        structure=item['reference_pdy'], \n        aligned_sequence=small_subunits_alignment[key].to_list()[0],\n        on_chain='B'\n    )\n    try:\n        reference_pdy = item['reference_pdy'].select('(chain B or chain D or chain F or chain H or chain J or chain L or chain N or chain P) and name CA')\n    except KeyError:\n        reference_pdy = item['reference_pdy'].select('(chain B or chain D or chain F or chain H or chain J or chain L or chain N or chain P) and name CA')\n\n    for i, (res, res_pdy) in enumerate(zip(u.residues, reference_pdy.getHierView().iterResidues())):\n        try:\n            resnum = backward_residue_map.index(res.resnum)\n        \n\n            exp01_rbcs_rmsf.append(\n                dict(\n                    rmsf=rmsf_values[i], resnum=resnum, chain=res_pdy.getChid(), code=key,\n                    time=item['time']\n\n                )\n            )    \n        except:\n            print(f\"error with {res.resnum}\")\n            continue\n    print(f\" done\")\n\nexp01_rbcs_rmsf = pd.DataFrame.from_records(exp01_rbcs_rmsf)\n\nWe finally map the RMSFs into a protein structure to visualize the RMSF spacially.\nexp01_rbcs_rmsf.to_csv(product['rbcs_rmsf'])\nexp01_rbcl_rmsf.to_csv(product['rbcl_rmsf'])\nfor residue, rmsf in zip(\n    exp01_md['reference_pdy'].loc['1bwv'].select('chain B').getHierView().iterResidues(), \n    exp01_rbcs_rmsf.query('code == \"1bwv\"').groupby('resnum')['rmsf'].mean().tolist()\n):\n    residue.setBetas(rmsf)\npdy.writePDB(product['pdb_bfactor_map'], exp01_md['reference_pdy'].loc['1bwv'].select('chain B'))", "params": {"md_reference_data": {"1bwv": {"dry_dcd": "1bwv.exp01.md01.dry.dcd", "dry_pdb": "1bwv.exp01.md01.dry.pdb", "time": "extant"}, "3zxw": {"dry_dcd": "3zxw.exp01.md01.dry.dcd", "dry_pdb": "3zxw.exp01.md01.dry.pdb", "time": "extant"}, "6ftl": {"dry_dcd": "6ftl.exp01.md01.dry.dcd", "dry_pdb": "6ftl.exp01.md01.dry.pdb", "time": "extant"}, "6ura": {"dry_dcd": "6ura.exp01.md01.dry.dcd", "dry_pdb": "6ura.exp01.md01.dry.pdb", "time": "extant"}, "8ruc": {"dry_dcd": "8ruc.exp01.md01.dry.dcd", "dry_pdb": "8ruc.exp01.md01.dry.pdb", "time": "extant"}, "anci": {"dry_dcd": "anci.exp01.md01.dry.dcd", "dry_pdb": "anci.exp01.md01.dry.pdb", "time": "ancient"}, "anciab": {"dry_dcd": "anciab.exp01.md01.dry.dcd", "dry_pdb": "anciab.exp01.md01.dry.pdb", "time": "ancient"}, "ancicd": {"dry_dcd": "ancicd.exp01.md01.dry.dcd", "dry_pdb": "ancicd.exp01.md01.dry.pdb", "time": "ancient"}, "ancia": {"dry_dcd": "ancia.exp01.md01.dry.dcd", "dry_pdb": "ancia.exp01.md01.dry.pdb", "time": "ancient"}, "ancib": {"dry_dcd": "ancib.exp01.md01.dry.dcd", "dry_pdb": "ancib.exp01.md01.dry.pdb", "time": "ancient"}, "anciip": {"dry_dcd": "anciip.exp01.md01.dry.dcd", "dry_pdb": "anciip.exp01.md01.dry.pdb", "time": "ancient"}, "ancip": {"dry_dcd": "ancip.exp01.md01.dry.dcd", "dry_pdb": "ancip.exp01.md01.dry.realigned.pdb", "time": "ancient"}}}}